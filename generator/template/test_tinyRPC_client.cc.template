/****************************************************
 *
 * ****     ***     ****    *   *    *****    *****
 * *  *    *   *   *        ****     ***        *
 * *   *    ***     ****    *   *    *****      *
 *
 * ${FILE_NAME}
 * ${CREATE_TIME}
 * Generated by tinyRPC framework tinyRPC_generator.py
****************************************************/
#include <google/protobuf/service.h>
#include "tinyRPC/net/rpc/rpc_channel.h"
#include "tinyRPC/net/rpc/rpc_controller.h"
#include "tinyRPC/net/rpc/rpc_closure.h"
#include "tinyRPC/common/config.h"
#include "tinyRPC/common/log.h"
${INCLUDE_PB_HEADER}
void test_client(const std::string& addr) {
  NEWMESSAGE(${REQUEST_TYPE}, request);
  NEWMESSAGE(${RESPONSE_TYPE}, response);
  // request->set_xxx(100);
  NEWRPCCONTROLLER(controller);
  controller->SetTimeout(2000);
  std::shared_ptr<tinyRPC::RpcClosure> closure = std::make_shared<tinyRPC::RpcClosure>([request, response, controller]() mutable {
    if (controller->GetErrorCode() == 0) {
      INFOLOG("call rpc success, request[%s], response[%s]", request->ShortDebugString().c_str(), response->ShortDebugString().c_str());
      
    } else {
      ERRORLOG("call rpc failed, request[%s], error code[%d], error info[%s]", 
        request->ShortDebugString().c_str(), 
        controller->GetErrorCode(), 
        controller->GetErrorInfo().c_str());
    }
    exit(0);
  });
  CALLRPRC(addr, ${STUBCLASS}, ${METHOD_NAME}, controller, request, response, closure);
} 
int main(int argc, char* argv[]) {
  tinyRPC::Config::setConfigPath(nullptr);
  tinyRPC::Logger::setLogLevel(tinyRPC::Config::getInstance()->m_log_level);
  tinyRPC::Logger::getInstance()->InitGlobalLogger(0);
  std::string addr = std::string(argv[1]) + ":" + std::string(argv[2]);  
  test_client(addr);
  return 0;
}